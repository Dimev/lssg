use std::{
    env::current_dir,
    fs::read_to_string,
    path::{Path, PathBuf},
};

use anyhow::{anyhow, Context};

use mlua::LuaSerdeExt;
use mlua::{Lua, LuaOptions, StdLib};
use serde::Deserialize;

use crate::api::globals::load_globals;
use crate::api::page::Page;
use crate::api::script::Script;
use crate::api::{directory::Directory, styles::load_styles};

/// Site config
#[derive(Deserialize, Debug)]
#[serde(rename_all = "kebab-case")]
struct SiteConfig {
    /// Whether to minify HTML (.html), defaults to false
    #[serde(default)]
    minify_html: bool,

    /// Whether to minify javascript (.js, .mjs), defaults to false
    #[serde(default)]
    minify_js: bool,

    /// Whether to minify css (.css), defaults to false
    /// Note that this is already done for the sass, scss and css in the style directory
    #[serde(default)]
    minify_css: bool,

    /// The optional 404 page to use when running the dev server
    dev_404: Option<PathBuf>,

    /// All extra config
    config: toml::Value,
}

/// Entire generated site
pub(crate) struct Site {
    /// the root page
    pub(crate) page: Page,

    /// All warnings generated by the site
    pub(crate) warnings: Vec<String>,

    /// Path the site was generated at
    pub(crate) path: PathBuf,

    /// The optional 404 page to use
    pub(crate) dev_404: Option<PathBuf>,
}

/// Errors generated by the site generator function, including the generated warnings
pub(crate) struct GenerateError {
    /// warnings emitted
    pub(crate) warnings: Vec<String>,

    /// Actual error
    pub(crate) error: anyhow::Error,
}

trait WithWarn<T, E> {
    fn with_warns<'a, I: Iterator<Item = &'a String>>(
        self,
        warnings: I,
    ) -> Result<T, GenerateError>;
}

impl<T, E: Into<GenerateError>> WithWarn<T, E> for Result<T, E> {
    fn with_warns<'a, I: Iterator<Item = &'a String>>(
        self,
        warnings: I,
    ) -> Result<T, GenerateError> {
        self.map_err(|x| {
            let mut gen = x.into();
            gen.warnings = warnings.map(|x| x.to_owned()).collect();
            gen
        })
    }
}

impl<E: Into<anyhow::Error>> From<E> for GenerateError {
    fn from(value: E) -> Self {
        Self {
            warnings: Vec::new(),
            error: value.into(),
        }
    }
}

impl Site {
    /// Generate the site
    pub(crate) fn generate(path: Option<PathBuf>, debug: bool) -> Result<Self, GenerateError> {
        // path to load from
        let path = path
            .map(|x| Ok(x) as Result<PathBuf, anyhow::Error>)
            .unwrap_or_else(|| {
                let dir = current_dir()?;

                // go up to find the dir containing the site.toml file
                Ok(dir
                    .ancestors()
                    .find(|x| x.join("site.toml").exists())
                    .ok_or_else(|| {
                        anyhow!(
                            "No site.toml found in the current directory or ancestors ({:?})",
                            dir
                        )
                    })?
                    .to_path_buf())
            })?
            .join("site.toml");

        // load the config
        let config = read_to_string(&path)?;

        // parse the config
        let config: SiteConfig = toml::from_str(&config)?;

        // path of the directory of where the site is
        let path = path
            .parent()
            .ok_or_else(|| anyhow!("site.toml file was not in a folder!"))?;

        // start lua
        let lua = Lua::new_with(
            StdLib::COROUTINE | StdLib::TABLE | StdLib::STRING | StdLib::UTF8 | StdLib::MATH,
            LuaOptions::new().catch_rust_panics(true),
        )?;

        // load the config to the global scope
        lua.globals().set("config", lua.to_value(&config.config)?)?;

        // load the static files
        let static_files =
            Directory::load_static(PathBuf::from("static/"), path.join("static/"), &lua)
                .context("Could not load static files directory")?;

        // load the styles
        let styles =
            load_styles(&lua, path.join("styles/")).context("Could not load styles directory")?;

        // load the globals
        let warnings = load_globals(&lua, path, debug)?;

        // load the root script
        // TODO: make this load directly into lua tables
        let script = Script::load(
            &PathBuf::from("site/"),
            &path.join("site/"),
            &lua,
            &static_files,
            &styles,
        )
        .with_warns(warnings.borrow().iter())?;

        // run the script
        let page = script.run().with_warns(warnings.borrow().iter())?;

        // get the warnings
        let warnings = warnings.borrow().clone();

        Ok(Site {
            page,
            warnings,
            path: path.into(),
            dev_404: config.dev_404,
        })
    }

    /// Write out the site to a given directory, or public/ in the site directory no path is given
    pub(crate) fn write_to_directory<P: AsRef<Path>>(
        &self,
        path: Option<P>,
    ) -> Result<(), anyhow::Error> {
        self.page.write_to_directory(
            path.map(|x| x.as_ref().into())
                .unwrap_or(self.path.join("public/")),
        ).context("Could not write to the output directory")
    }
}
